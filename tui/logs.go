package tui

import (
	"bufio"
	"context"
	"encoding/json"
	"fmt"
	"strings"
	"time"

	"git.sr.ht/~rockorager/vaxis"
	"git.sr.ht/~rockorager/vaxis/vxfw"
	"git.sr.ht/~rockorager/vaxis/vxfw/list"
	"git.sr.ht/~rockorager/vaxis/vxfw/richtext"
	"git.sr.ht/~rockorager/vaxis/vxfw/text"
	"github.com/picosh/pico/shared"
	"github.com/picosh/utils"
	pipeLogger "github.com/picosh/utils/pipe/log"
)

type LogLineLoaded struct {
	Line map[string]any
}

type LogsPage struct {
	shared *SharedModel

	input    *TextInput
	list     *list.Dynamic
	focus    string
	logs     []*LogLine
	filtered []int
	ctx      context.Context
	done     context.CancelFunc
}

func NewLogsPage(shrd *SharedModel) *LogsPage {
	ctx, cancel := context.WithCancel(shrd.Session.Context())
	page := &LogsPage{
		shared: shrd,
		input:  NewTextInput("filter logs"),
		ctx:    ctx,
		done:   cancel,
	}
	page.list = &list.Dynamic{Builder: page.getWidget, DisableEventHandlers: true}
	return page
}

func (m *LogsPage) Footer() []Shortcut {
	return []Shortcut{
		{Shortcut: "tab", Text: "focus"},
	}
}

func (m *LogsPage) CaptureEvent(ev vaxis.Event) (vxfw.Command, error) {
	switch msg := ev.(type) {
	case vaxis.Key:
		if msg.Matches(vaxis.KeyTab) {
			if m.focus == "list" {
				m.focus = "input"
				return m.input.FocusIn()
			}
			m.focus = "list"
			cmd, _ := m.input.FocusOut()
			return vxfw.BatchCmd([]vxfw.Command{cmd, vxfw.FocusWidgetCmd(m.list)}), nil
		}

		if m.focus == "input" {
			m.filterLogs()
			return vxfw.RedrawCmd{}, nil
		}
	}
	return nil, nil
}

func (m *LogsPage) filterLogs() {
	match := m.input.GetValue()
	m.filtered = []int{}
	for idx, ll := range m.logs {
		if match == "" {
			m.filtered = append(m.filtered, idx)
			continue
		}

		lvlMatch := matched(ll.Level, match)
		msgMatch := matched(ll.Msg, match)
		serviceMatch := matched(ll.Service, match)
		errMatch := matched(ll.ErrMsg, match)
		urlMatch := matched(ll.Url, match)
		statusMatch := matched(fmt.Sprintf("%d", ll.Status), match)
		if !lvlMatch && !msgMatch && !serviceMatch && !errMatch && !urlMatch && !statusMatch {
			continue
		}

		m.filtered = append(m.filtered, idx)
	}

	if len(m.filtered) > 0 {
		m.list.SetCursor(uint(len(m.filtered) - 1))
	}
}

func (m *LogsPage) HandleEvent(ev vaxis.Event, phase vxfw.EventPhase) (vxfw.Command, error) {
	switch msg := ev.(type) {
	case PageIn:
		go func() {
			_ = m.connectToLogs()
		}()
		return m.input.FocusIn()
	case PageOut:
		m.done()
	case LogLineLoaded:
		m.logs = append(m.logs, NewLogLine(msg.Line))
		m.filterLogs()
		return vxfw.RedrawCmd{}, nil
	}
	return nil, nil
}

func (m *LogsPage) Draw(ctx vxfw.DrawContext) (vxfw.Surface, error) {
	root := vxfw.NewSurface(ctx.Max.Width, ctx.Max.Height, m)

	if len(m.logs) == 0 {
		txt := text.New("This view shows all logs generated by our services tagged with your user.  This view will show errors triggered by your pages sites, blogs, tuns, etc.  Logs will show up here in realtime as they are generated.  There is no log buffer.")
		txtSurf, _ := txt.Draw(ctx)
		root.AddChild(0, 0, txtSurf)
	} else {
		listSurf, _ := m.list.Draw(createDrawCtx(ctx, ctx.Max.Height-4))
		root.AddChild(0, 0, listSurf)
	}

	inp, _ := m.input.Draw(createDrawCtx(ctx, 4))
	root.AddChild(0, int(ctx.Max.Height)-3, inp)

	return root, nil
}

func (m *LogsPage) getWidget(i uint, cursor uint) vxfw.Widget {
	if len(m.filtered) == 0 {
		return nil
	}

	if int(i) >= len(m.filtered) {
		return nil
	}

	idx := m.filtered[i]
	return logToWidget(m.logs[idx])
}

func (m *LogsPage) connectToLogs() error {
	conn := shared.NewPicoPipeClient()
	drain, err := pipeLogger.ReadLogs(m.ctx, m.shared.Logger, conn)
	if err != nil {
		return err
	}

	scanner := bufio.NewScanner(drain)
	scanner.Buffer(make([]byte, 32*1024), 32*1024)
	for scanner.Scan() {
		line := scanner.Text()
		parsedData := map[string]any{}

		err := json.Unmarshal([]byte(line), &parsedData)
		if err != nil {
			m.shared.Logger.Error("json unmarshal", "err", err, "line", line)
			continue
		}

		// user := utils.AnyToStr(parsedData, "user")
		// userId := utils.AnyToStr(parsedData, "userId")
		// if user == m.shared.User.Name || userId == m.shared.User.ID {
		m.shared.App.PostEvent(LogLineLoaded{parsedData})
		// }
	}

	return nil
}

func matched(str, match string) bool {
	prim := strings.ToLower(str)
	mtch := strings.ToLower(match)
	return strings.Contains(prim, mtch)
}

type LogLine struct {
	Date    string
	Service string
	Level   string
	Msg     string
	ErrMsg  string
	Status  int
	Url     string
}

func NewLogLine(data map[string]any) *LogLine {
	rawtime := utils.AnyToStr(data, "time")
	service := utils.AnyToStr(data, "service")
	level := utils.AnyToStr(data, "level")
	msg := utils.AnyToStr(data, "msg")
	errMsg := utils.AnyToStr(data, "err")
	status := utils.AnyToFloat(data, "status")
	url := utils.AnyToStr(data, "url")
	date, err := time.Parse(time.RFC3339Nano, rawtime)
	dateStr := rawtime
	if err == nil {
		dateStr = date.Format(time.RFC3339)
	}

	return &LogLine{
		Date:    dateStr,
		Service: service,
		Level:   level,
		Msg:     msg,
		ErrMsg:  errMsg,
		Status:  int(status),
		Url:     url,
	}
}

func logToWidget(ll *LogLine) vxfw.Widget {
	segs := []vaxis.Segment{
		{Text: ll.Date + " "},
		{Text: ll.Service + " "},
	}

	if ll.Level == "ERROR" {
		segs = append(segs, vaxis.Segment{Text: ll.Level, Style: vaxis.Style{Background: red}})
	} else {
		segs = append(segs, vaxis.Segment{Text: ll.Level})
	}

	segs = append(segs, vaxis.Segment{Text: " " + ll.Msg + " "})
	if ll.ErrMsg != "" {
		segs = append(segs, vaxis.Segment{Text: ll.ErrMsg + " ", Style: vaxis.Style{Foreground: red}})
	}

	if ll.Status > 0 {
		if ll.Status >= 200 && ll.Status < 300 {
			segs = append(segs, vaxis.Segment{
				Text:  fmt.Sprintf("%d ", ll.Status),
				Style: vaxis.Style{Foreground: green},
			})
		} else {
			segs = append(segs,
				vaxis.Segment{
					Text:  fmt.Sprintf("%d ", ll.Status),
					Style: vaxis.Style{Foreground: red},
				})
		}
	}

	segs = append(segs, vaxis.Segment{Text: ll.Url + " "})

	txt := richtext.New(segs)
	return txt
}
