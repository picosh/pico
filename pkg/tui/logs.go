package tui

import (
	"bufio"
	"context"
	"encoding/json"
	"fmt"
	"strings"
	"time"

	"git.sr.ht/~rockorager/vaxis"
	"git.sr.ht/~rockorager/vaxis/vxfw"
	"git.sr.ht/~rockorager/vaxis/vxfw/list"
	"git.sr.ht/~rockorager/vaxis/vxfw/richtext"
	"git.sr.ht/~rockorager/vaxis/vxfw/text"
	"github.com/picosh/pico/pkg/shared"
	"github.com/picosh/utils"
	pipeLogger "github.com/picosh/utils/pipe/log"
)

type LogLineLoaded struct {
	Line map[string]any
}

type LogsPage struct {
	shared *SharedModel

	input    *TextInput
	list     *list.Dynamic
	filtered []int
	logs     []*LogLine
	ctx      context.Context
	done     context.CancelFunc
}

func NewLogsPage(shrd *SharedModel) *LogsPage {
	page := &LogsPage{
		shared: shrd,
		input:  NewTextInput("filter logs"),
	}
	page.list = &list.Dynamic{Builder: page.getWidget, DisableEventHandlers: true}
	return page
}

func (m *LogsPage) Footer() []Shortcut {
	return []Shortcut{}
}

func (m *LogsPage) filterLogLine(match string, ll *LogLine) bool {
	if match == "" {
		return true
	}

	lvlMatch := matched(ll.Level, match)
	msgMatch := matched(ll.Msg, match)
	serviceMatch := matched(ll.Service, match)
	errMatch := matched(ll.ErrMsg, match)
	urlMatch := matched(ll.Url, match)
	statusMatch := matched(fmt.Sprintf("%d", ll.Status), match)

	if !lvlMatch && !msgMatch && !serviceMatch && !errMatch && !urlMatch && !statusMatch {
		return false
	}

	return true
}

func (m *LogsPage) filterLogs() {
	match := m.input.GetValue()
	filtered := []int{}
	for idx, ll := range m.logs {
		if m.filterLogLine(match, ll) {
			filtered = append(m.filtered, idx)
		}
	}
	m.filtered = filtered

	// scroll to bottom
	if len(m.filtered) > 0 {
		m.list.SetCursor(uint(len(m.filtered) - 1))
	}
}

func (m *LogsPage) CaptureEvent(ev vaxis.Event) (vxfw.Command, error) {
	switch ev.(type) {
	case vaxis.Key:
		m.filterLogs()
		return vxfw.RedrawCmd{}, nil
	}
	return nil, nil
}

func (m *LogsPage) HandleEvent(ev vaxis.Event, phase vxfw.EventPhase) (vxfw.Command, error) {
	switch msg := ev.(type) {
	case PageIn:
		go func() {
			_ = m.connectToLogs()
		}()
		return m.input.FocusIn()
	case PageOut:
		m.done()
	case LogLineLoaded:
		ll := NewLogLine(msg.Line)
		m.logs = append(m.logs, ll)
		m.filterLogs()
		return vxfw.RedrawCmd{}, nil
	}
	return nil, nil
}

func (m *LogsPage) Draw(ctx vxfw.DrawContext) (vxfw.Surface, error) {
	root := vxfw.NewSurface(ctx.Max.Width, ctx.Max.Height, m)

	if len(m.logs) == 0 {
		txt := text.New("This view shows all logs generated by our services tagged with your user.  This view will show errors triggered by your pages sites, blogs, tuns, etc.  Logs will show up here in realtime as they are generated.  There is no log buffer.")
		txtSurf, _ := txt.Draw(ctx)
		root.AddChild(0, 0, txtSurf)
	} else {
		listSurf, _ := m.list.Draw(createDrawCtx(ctx, ctx.Max.Height-4))
		root.AddChild(0, 0, listSurf)
	}

	inp, _ := m.input.Draw(createDrawCtx(ctx, 4))
	root.AddChild(0, int(ctx.Max.Height)-3, inp)

	return root, nil
}

func (m *LogsPage) getWidget(i uint, cursor uint) vxfw.Widget {
	if len(m.filtered) == 0 {
		return nil
	}

	if int(i) >= len(m.filtered) {
		return nil
	}

	idx := m.filtered[i]
	return logToWidget(m.logs[idx])
}

func (m *LogsPage) connectToLogs() error {
	ctx, cancel := context.WithCancel(m.shared.Session.Context())
	defer cancel()

	m.ctx = ctx
	m.done = cancel

	conn := shared.NewPicoPipeClient()
	drain, err := pipeLogger.ReadLogs(ctx, m.shared.Logger, conn)
	if err != nil {
		return err
	}

	scanner := bufio.NewScanner(drain)
	scanner.Buffer(make([]byte, 32*1024), 32*1024)
	for scanner.Scan() {
		line := scanner.Text()
		parsedData := map[string]any{}

		err := json.Unmarshal([]byte(line), &parsedData)
		if err != nil {
			m.shared.Logger.Error("json unmarshal", "err", err, "line", line)
			continue
		}

		user := utils.AnyToStr(parsedData, "user")
		userId := utils.AnyToStr(parsedData, "userId")
		if user == m.shared.User.Name || userId == m.shared.User.ID {
			m.shared.App.PostEvent(LogLineLoaded{parsedData})
		}
	}

	if err := scanner.Err(); err != nil {
		m.shared.Logger.Error("scanner error", "err", err)
		return err
	}

	return nil
}

func matched(str, match string) bool {
	prim := strings.ToLower(str)
	mtch := strings.ToLower(match)
	return strings.Contains(prim, mtch)
}

type LogLine struct {
	Date    string
	Service string
	Level   string
	Msg     string
	ErrMsg  string
	Status  int
	Url     string
}

func NewLogLine(data map[string]any) *LogLine {
	rawtime := utils.AnyToStr(data, "time")
	service := utils.AnyToStr(data, "service")
	level := utils.AnyToStr(data, "level")
	msg := utils.AnyToStr(data, "msg")
	errMsg := utils.AnyToStr(data, "err")
	status := utils.AnyToFloat(data, "status")
	url := utils.AnyToStr(data, "url")
	date, err := time.Parse(time.RFC3339Nano, rawtime)
	dateStr := rawtime
	if err == nil {
		dateStr = date.Format(time.RFC3339)
	}

	return &LogLine{
		Date:    dateStr,
		Service: service,
		Level:   level,
		Msg:     msg,
		ErrMsg:  errMsg,
		Status:  int(status),
		Url:     url,
	}
}

func logToWidget(ll *LogLine) vxfw.Widget {
	segs := []vaxis.Segment{
		{Text: ll.Date + " "},
		{Text: ll.Service + " "},
	}

	if ll.Level == "ERROR" {
		segs = append(segs, vaxis.Segment{Text: ll.Level, Style: vaxis.Style{Background: red}})
	} else {
		segs = append(segs, vaxis.Segment{Text: ll.Level})
	}

	segs = append(segs, vaxis.Segment{Text: " " + ll.Msg + " "})
	if ll.ErrMsg != "" {
		segs = append(segs, vaxis.Segment{Text: ll.ErrMsg + " ", Style: vaxis.Style{Foreground: red}})
	}

	if ll.Status > 0 {
		if ll.Status >= 200 && ll.Status < 300 {
			segs = append(segs, vaxis.Segment{
				Text:  fmt.Sprintf("%d ", ll.Status),
				Style: vaxis.Style{Foreground: green},
			})
		} else {
			segs = append(segs,
				vaxis.Segment{
					Text:  fmt.Sprintf("%d ", ll.Status),
					Style: vaxis.Style{Foreground: red},
				})
		}
	}

	segs = append(segs, vaxis.Segment{Text: ll.Url + " "})

	txt := richtext.New(segs)
	return txt
}
